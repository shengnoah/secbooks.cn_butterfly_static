{"title":"用RESTY-HTTP实现Graylog的Widget更新与查询","uid":"07e149df00baf09dc3d8d5e82a638745","slug":"old_topic/2016-09-17-350","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-16T11:44:51.885Z","comments":true,"path":"api/articles/old_topic/2016-09-17-350.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：糖果</p>\n<p>MoonScript for GrayLog是之前写的一个基于Lapis与Simple HTTP的Graylog日志查询SDK，<br />\n支持Stream查询，最近为了做自动化分析，加入了新的接口中调用功能，加入了对Dashboard<br />\nwidgets和更新与查询，通过这个程序，实现一些反扫逻辑。</p>\n<pre class=\"highlight\"><code class=\"lua\">\n    @putRequest:(req_url, data) =&gt;\n        http = <span class=\"built_in\">require</span> <span class=\"string\">&quot;resty.http&quot;</span>\n        httpc = http.new()\n        metadata = &#123;\n          method:<span class=\"string\">&quot;PUT&quot;</span>,\n          body: data,\n          headers: <span class=\"built_in\">self</span>.headers_info\n        &#125;\n\n        res, err = httpc\\request_uri(req_url, metadata)\n\n        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> res\n          ngx.say(<span class=\"string\">&quot;failed to request: &quot;</span>, err)\n          <span class=\"keyword\">return</span>\n        <span class=\"keyword\">return</span> res.body\n\n\n    @updateWidget: (dashboardId, widgetId,jsonBody) =&gt;\n        errList = &#123;&#125;\n        <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(dashboardId) == <span class=\"string\">&#x27;nil&#x27;</span>\n            <span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(errList, <span class=\"string\">&quot;dashboard id is nil\\n&quot;</span>)\n\n        <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(widgetId) == <span class=\"string\">&#x27;nil&#x27;</span>\n            <span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(errList, <span class=\"string\">&quot;widget id is nil\\n&quot;</span>)\n\n        <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(jsonBody) == <span class=\"string\">&#x27;nil&#x27;</span>\n            <span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(errList, <span class=\"string\">&quot;json body is nil\\n&quot;</span>)\n\n        num = <span class=\"built_in\">table</span>.<span class=\"built_in\">getn</span>(errList) \n        <span class=\"keyword\">if</span> num &gt; <span class=\"number\">0</span> \n            <span class=\"keyword\">return</span> errList\n\n\n        url = <span class=\"string\">&quot;http://&quot;</span>..<span class=\"built_in\">self</span>.host..<span class=\"string\">&quot;:&quot;</span>..<span class=\"built_in\">self</span>.port\n        req_url = url..<span class=\"string\">&#x27;/dashboards/&#x27;</span>..dashboardId..<span class=\"string\">&#x27;/widgets/&#x27;</span>..widgetId\n\n        <span class=\"built_in\">self</span>.headers_info = &#123;\n            <span class=\"string\">&#x27;Authorization&#x27;</span>: <span class=\"built_in\">self</span>.auth, \n            <span class=\"string\">&#x27;Accept&#x27;</span>: <span class=\"string\">&#x27;*/*&#x27;</span>,\n            <span class=\"string\">&#x27;Content-Type&#x27;</span>:<span class=\"string\">&#x27;application/json&#x27;</span>\n        &#125;\n\n        <span class=\"built_in\">self</span>\\putRequest req_url, jsonBody\n        <span class=\"keyword\">return</span> <span class=\"number\">1</span>\n\n\n    @getRequest:(req_url) =&gt;\n        http = <span class=\"built_in\">require</span> <span class=\"string\">&quot;resty.http&quot;</span>\n        httpc = http.new()\n        metadata = &#123;\n          method:<span class=\"string\">&quot;GET&quot;</span>,\n          headers: <span class=\"built_in\">self</span>.headers_info\n        &#125;\n\n        res, err = httpc\\request_uri(req_url, metadata)\n\n        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> res\n          ngx.say(<span class=\"string\">&quot;failed to request: &quot;</span>, err)\n          <span class=\"keyword\">return</span>\n\n        ngx.<span class=\"built_in\">status</span> = res.<span class=\"built_in\">status</span>\n        <span class=\"keyword\">return</span> res.body\n\n\n    @getWidgetValue: (dashboardId, widgetId) =&gt;\n        errList = &#123;&#125;\n        <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(dashboardId) == <span class=\"string\">&#x27;nil&#x27;</span>\n            <span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(errList, <span class=\"string\">&quot;dashboard id is nil\\n&quot;</span>)\n\n        <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(widgetId) == <span class=\"string\">&#x27;nil&#x27;</span>\n            <span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(errList, <span class=\"string\">&quot;widget id is nil\\n&quot;</span>)\n\n        num = <span class=\"built_in\">table</span>.<span class=\"built_in\">getn</span>(errList) \n        <span class=\"keyword\">if</span> num &gt; <span class=\"number\">0</span> \n            <span class=\"keyword\">return</span> errList\n\n        url = <span class=\"string\">&quot;http://&quot;</span>..<span class=\"built_in\">self</span>.host..<span class=\"string\">&quot;:&quot;</span>..<span class=\"built_in\">self</span>.port\n        req_url = url..<span class=\"string\">&#x27;/dashboards/&#x27;</span>..dashboardId..<span class=\"string\">&#x27;/widgets/&#x27;</span>..widgetId..<span class=\"string\">&#x27;/value&#x27;</span>\n\n        <span class=\"built_in\">self</span>.headers_info = &#123;\n            <span class=\"string\">&#x27;Authorization&#x27;</span>: <span class=\"built_in\">self</span>.auth, \n            <span class=\"string\">&#x27;Accept&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,\n        &#125;\n\n        ret = <span class=\"built_in\">self</span>\\getRequest req_url\n        <span class=\"keyword\">return</span> ret\n        \n</code></pre>\n<p>这次没有使用过去端末加JSON数据请求的方式，把simple http换成了RESTY-HTTP,项目名改<br />\n了，叫“Finder”。</p>\n<p>本文请不要用于商业目地，非商业转载请署名原作者与原文链接。<br />\n<a href=\"https://www.moonscript.cn/openresty/resty-http-for-graylog/\">https://www.moonscript.cn/openresty/resty-http-for-graylog/</a></p>\n","text":"作者：糖果 MoonScript for GrayLog是之前写的一个基于Lapis与Simple HTTP的Graylog日志查询SDK， 支持Stream查询，最近为了做自动化分析，加入了新的接口中调用功能，加入了对Dashboard widgets和更新与查询，通过这个程序...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Scrapy快速写爬虫","uid":"a0f1485d8813f2781144a51b0a71a712","slug":"old_topic/2016-09-17-342","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-16T11:44:51.882Z","comments":true,"path":"api/articles/old_topic/2016-09-17-342.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"看到别人的教程，学着测了一下，不错。 1scrapy startproject ren 直接保存到文件中 123456789101112131415# -*- coding: utf-8 -*-import scrapyclass LuarenSpider(scrapy.Spid...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MoonScript与Redis客户端","uid":"55c8ceefd620d530c7de11d61153ba84","slug":"old_topic/2016-09-17-346","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-16T11:44:51.882Z","comments":true,"path":"api/articles/old_topic/2016-09-17-346.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"所谓的Redis LUA客户端有两种版本，一种就是本地可运行版本，还有一个版本是OpenResty的版本，下面介绍的这段Moonscript段代码是本地版的。 作者：糖果 candylab.moon 123456789redis = require \"redis\"client =...","link":"","photos":[],"count_time":{"symbolsCount":675,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}