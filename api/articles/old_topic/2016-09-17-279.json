{"title":"Tail Call 到底有啥用？","uid":"d50433282a5b8a29764977173d70c1a2","slug":"old_topic/2016-09-17-279","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-16T11:44:51.870Z","comments":true,"path":"api/articles/old_topic/2016-09-17-279.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"content":"<p>作者：ms2008</p>\n<p>整理编辑：糖果</p>\n<p>在聊今天这个话题之前，我们需要知道什么叫 tail call。先来看下，lua 程序设计是怎么定义的：</p>\n<p>尾调用是一种类似在函数结尾的 goto 调用，当函数最后一个动作是调用另外一个函数时，我们称这种调用尾调用。例如：</p>\n<p>function f(x)<br />\nreturn g(x)<br />\nend</p>\n<p>g 的调用是尾调用。</p>\n<p>例子中 f 调用 g 后不会再做任何事情，这种情况下当被调用函数 g 结束时程序不需要返回到调用者 f；所以尾调用之后程序不需要在栈中保留关于调用者的任何信息。一些编译器比如 Lua 解释器利用这种特性在处理尾调用时不使用额外的栈，我们称这种语言支持正确的尾调用。</p>\n<p>由于尾调用不需要使用栈空间，那么尾调用递归的层次可以无限制的。</p>\n<p>是不是有些迷糊？那我继续来解释下「详情可以参考廖雪峰的blog」：</p>\n<p>我们知道在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。递归函数的优点是定义简单，逻辑清晰。但是使用递归函数有个要命的缺点就是需要注意防止栈溢出！</p>\n<p>在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试这个求阶乘的用例：</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/sOId2kGKNxhdFrfmk2Uo0sz8FdpYZj3d4S3HkiblePAqzcsrRpuH29O6Zn4Z8vsEIY4ickhHwOzrQIDVAMsCuDHA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"图片\" /></p>\n<p>解决递归调用栈溢出的方法是通过尾递归优化。尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>\n<p>上面的 fact(n) 函数由于 return n * fact(n - 1) 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/sOId2kGKNxhdFrfmk2Uo0sz8FdpYZj3dDZ3u1yYLnBaRtjGnQnwFFbA7M59aWyFibGKYR8hroS0FhkI9nQJjdyQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"图片\" /></p>\n<p>可以看到，return fact_iter(n-1, now<em>n) 仅返回递归函数本身，n-1 和 now</em>n 在函数调用前就会被计算，不影响函数调用。</p>\n<p>任何递归函数都存在栈溢出的问题。尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。这也正是 tail call 的威力所在。</p>\n<p>遗憾的是，大多数编程语言没有针对尾递归做优化，当然 lua 除外 😃</p>\n","text":"作者：ms2008 整理编辑：糖果 在聊今天这个话题之前，我们需要知道什么叫 tail call。先来看下，lua 程序设计是怎么定义的： 尾调用是一种类似在函数结尾的 goto 调用，当函数最后一个动作是调用另外一个函数时，我们称这种调用尾调用。例如： function f(x...","link":"","photos":[],"count_time":{"symbolsCount":979,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"微博API发送微博","uid":"a7777311d1e67a84d45b8c65389d0ce5","slug":"old_topic/2016-09-17-276","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-16T11:44:51.870Z","comments":true,"path":"api/articles/old_topic/2016-09-17-276.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"使用微博的API和SDK的其中的关键一步是取得token. 而取得token是需要通过oauth2认证才可以得到。 下面是一段取得token的代码逻辑： 123456789APP_KEY ='012345678'APP_SECRET = '01234567891011121314...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"TMUX最常用操作命令","uid":"65ce57f5fdb9c6ca938fd44776fc3ed9","slug":"old_topic/2016-09-17-277","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-16T11:44:51.870Z","comments":true,"path":"api/articles/old_topic/2016-09-17-277.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 一般情况下，当你用SSH链接VPS，然后关掉terminal的操作窗口时，所有的当前操作都结束了。而如果用TMUX,当前正在运行的非后台操作会话还会存在，下面是TMUX最常用的操作了。 1.创建新会话 tmux new -s candylab 2.选择新会话 tmux...","link":"","photos":[],"count_time":{"symbolsCount":812,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}